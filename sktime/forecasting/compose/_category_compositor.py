# copyright: sktime developers, BSD-3-Clause License (see LICENSE file)
"""Implements a compositor to utilize forecasters based on ADI/CV categorization."""

__author__ = ["shlok191"]

from sktime.forecasting.base import BaseForecaster
from sktime.forecasting.croston import Croston
from sktime.forecasting.naive import NaiveForecaster
from sktime.forecasting.trend import PolynomialTrendForecaster
from sktime.transformations.base import BaseTransformer
from sktime.transformations.series.adi_cv import ADICVTransformer

adi_cv_transformer = ADICVTransformer(features=["class"])


class CategoryCompositor(BaseForecaster):
    """Compositor that utilizes varying forecasters by time series data's nature.

    Applies a series-to-primitives transformer on a given time series. Based on the
    generated value from the transformer, one of multiple forecasters provided by
    the user in the form of a dictionary (key => category, value => forecaster) is
    selected. Finally, the chosen forecaster is fit to the data for future predictions.

    Parameters
    ----------
    forecasters : dict[sktime forecasters]
        dict of forecasters with the key corresponding to categories generated
        by the given transformer and the value corresponding to a sktime forecaster.

    transformer : sktime transformer, default = ADICVTransformer()
        A series-to-primitives sk-time transformer that generates a value
        which can be used to quantify a choice of forecaster for the time series.

    fallback_forecaster : sktime forecaster | None, Optional
        A fallback forecaster that will be used if the category generated by
        the transformer does not match any of the given forecasters.

    Raises
    ------
    AssertionError: If a valid transformer (an instance of BaseTransformer)
    is not passed or if valid forecasters (instances of BaseForecaster) are not given.
    """

    _tags = {
        "y_inner_mtype": "pd.DataFrame",
        "X_inner_mtype": "pd.DataFrame",
        "scitype:y": "both",
        "ignores-exogeneous-X": False,
        "requires-fh-in-fit": False,
        "enforce_index_type": None,
        "authors": ["shlok191"],
        "maintainers": ["shlok191"],
        "python_version": None,
    }

    def __init__(
        self,
        forecasters,
        transformer=adi_cv_transformer,
        fallback_forecaster=None,
    ):
        # saving arguments to object storage
        self.transformer = transformer
        self.forecasters = forecasters
        self.fallback_forecaster = fallback_forecaster

        super().__init__()

        # validating passed arguments
        assert isinstance(transformer, BaseTransformer)

        for forecaster in forecasters.values():
            assert isinstance(forecaster, BaseForecaster)

        # All checks OK!
        # Assigning all capabilities on the basis of the capabilities
        # of the passed forecasters

        capability_tags = {
            "ignores-exogeneous-X": False,
            "requires-fh-in-fit": False,
            "X-y-must-have-same-index": False,
            "enforce_index_type": False,
            "handles-missing-data": False,
            "capability:insample": False,
            "capability:pred_int": False,
            "capability:pred_int:insample": False,
        }

        # Traversing all capability tags
        for tag in capability_tags.keys():
            # Checking the equivalent forecaster tags
            true_for_all = True

            for forecaster in self.forecasters.values():
                # Fetching the forecaster tags
                forecaster_tags = forecaster.get_tags()

                if tag not in forecaster_tags or forecaster_tags[tag] is False:
                    true_for_all = False
                    break

            capability_tags[tag] = true_for_all

        # Update the capability tags
        self.set_tags(**capability_tags)

    def _fit(self, y, X=None, fh=None):
        """Fit forecaster to training data.

        private _fit containing the core logic, called from fit

        Writes to self:
            Sets fitted model attributes ending in "_".

        Parameters
        ----------
        y : Pd.Series
            The target time series to which we fit the data.

        fh : ForecastingHorizon | None, optional (default=None)
            The forecasting horizon with the steps ahead to predict.

        X : Pd.Series | None, optional (default=None)
            No exogenous variables are used for this.

        Returns
        -------
        self : reference to self

        Raises
        ------
        ValueError: If the extrapolated category has no provided forecaster
        and if there is no fallback forecaster provided to the object!

        Example:

        If the passed transformer is an ADICVTransformer(), and the generated
        series is a lumpy series; however, if there is no key matching "lumpy"
        in the forecasters parameter, the fallback_forecaster will be used.
        Additionally, if the fallback_forecaster is None, a ValueError will be thrown.
        """
        # passing time series through the provided transformer!
        self.category_ = self.transformer.fit_transform(X=y).iloc[0, 0]

        # check if we have an available forecaster
        if self.category_ not in self.forecasters:
            if self.fallback_forecaster is None:
                raise ValueError(
                    "Forecaster not provided for given"
                    + f"time series of type {self.category_}"
                    + "and no fallback forecaster provided to use for this case."
                )

            # Adopt the fallback forecaster if possible
            else:
                self.chosen_forecaster_ = self.fallback_forecaster

        else:
            self.chosen_forecaster_ = self.forecasters[self.category_]

        # fitting the forecaster!
        self.chosen_forecaster_.fit(y=y, X=X, fh=fh)
        self._is_fitted = True

        return self

    def _predict(self, fh, X):
        """Forecast time series at future horizon.

        private _predict containing the core logic, called from predict

        State required:
            Requires state to be "fitted".

        Accesses in self:
            Fitted model attributes ending in "_"
            self.cutoff

        Parameters
        ----------
        fh : guaranteed to be ForecastingHorizon or None, optional (default=None)
            The forecasting horizon with the steps ahead to to predict.
            If not passed in _fit, guaranteed to be passed here

        X : sktime time series object, optional (default=None)
            guaranteed to be of an mtype in self.get_tag("X_inner_mtype")
            Exogeneous time series for the forecast

        Returns
        -------
        y_pred : sktime time series object
            should be of the same type as seen in _fit, as in "y_inner_mtype" tag
            Point predictions
        """
        # Obtain the prediction values for the given horizon.
        y_pred = self.chosen_forecaster_(fh=fh, X=X)

        return y_pred

    def _update(self, y, X=None, update_params=True):
        """Update time series to incremental training data.

        private _update containing the core logic, called from update

        State required:
            Requires state to be "fitted".

        Accesses in self:
            Fitted model attributes ending in "_"
            self.cutoff

        Writes to self:
            Sets fitted model attributes ending in "_", if update_params=True.
            Does not write to self if update_params=False.

        Parameters
        ----------
        y : sktime time series object
            guaranteed to be of an mtype in self.get_tag("y_inner_mtype")
            Time series with which to update the forecaster.
            if self.get_tag("scitype:y")=="univariate":
                guaranteed to have a single column/variable
            if self.get_tag("scitype:y")=="multivariate":
                guaranteed to have 2 or more columns
            if self.get_tag("scitype:y")=="both": no restrictions apply
        X :  sktime time series object, optional (default=None)
            guaranteed to be of an mtype in self.get_tag("X_inner_mtype")
            Exogeneous time series for the forecast
        update_params : bool, optional (default=True)
            whether model parameters should be updated

        Returns
        -------
        self : reference to self
        """
        self.chosen_forecaster_.update(y=y, X=X, update_params=update_params)

    def _update_predict_single(self, y, fh, X=None, update_params=True):
        """Update forecaster and then make forecasts.

        Implements default behaviour of calling update and predict sequentially, but can
        be overwritten by subclasses to implement more efficient updating algorithms
        when available.
        """
        self.update(y, X, update_params=update_params)
        return self.predict(fh, X)

    @classmethod
    def get_test_params(cls, parameter_set="default"):
        """Return testing parameter settings for the estimator.

        Parameters
        ----------
        parameter_set : str, default="default"
            Name of the set of test parameters to return, for use in tests. If no
            special parameters are defined for a value, will return `"default"` set.
            There are currently no reserved values for forecasters.

        Returns
        -------
        params : dict or list of dict, default = {}
            Parameters to create testing instances of the class
            Each dict are parameters to construct an "interesting" test instance, i.e.,
            `MyClass(**params)` or `MyClass(**params[i])` creates a valid test instance.
            `create_test_instance` uses the first (or only) dictionary in `params`
        """
        param1 = {
            "forecasters": {
                "smooth": NaiveForecaster(),
                "erratic": PolynomialTrendForecaster(),
                "intermittent": Croston(),
                "lumpy": NaiveForecaster(),
            },
            "transformer": ADICVTransformer(features=["class"]),
            "fallback_forecaster": None,
        }

        # Attempt to utilize the fallback forecaster
        param2 = {
            "forecasters": {},
            "transformer": ADICVTransformer(features=["class"]),
            "fallback_forecaster": Croston(),
        }

        params = [param1, param2]
        return params
